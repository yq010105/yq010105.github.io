<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="summary"><title>Python多线程学习 | Yun.Qi</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.png"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.png"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Python多线程学习</h1><a id="logo" href="/.">Yun.Qi</a><p class="summary">Note/Diary</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Home</i></a><a href="/archives/"><i class="fa fa-archive"> Archive</i></a><a href="/about/"><i class="fa fa-user"> About</i></a><a href="/diary/"><i class="fa fa-book"> Diary</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Python多线程学习</h1><div class="post-meta">2020-04-04<span> | </span><span class="category"><a href="/categories/%E5%AD%A6%E4%B9%A0%E5%8A%9B/">学习力</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 3,447</span><span class="post-meta-item-text"> Words</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i><span class="post-count"> 14</span><span class="post-meta-item-text"> Minutes</span></span></span></div><div class="clear"><div class="toc-article" id="toc"><div class="toc-title">目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-初步认识多线程"><span class="toc-text">1. 初步认识多线程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-线程基础"><span class="toc-text">2. 线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-线程的开始"><span class="toc-text">2.1 线程的开始</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-线程结束时停止"><span class="toc-text">2.2 线程结束时停止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-线程的名称"><span class="toc-text">2.3 线程的名称</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Thread函数"><span class="toc-text">2.4 Thread函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Thread对象"><span class="toc-text">2.5 Thread对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-threading"><span class="toc-text">2.6 threading</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-线程进阶"><span class="toc-text">3. 线程进阶</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-派生Thread-的子类，并创建子类的实例"><span class="toc-text">3.1 派生Thread 的子类，并创建子类的实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-获取可调用对象的返回值"><span class="toc-text">3.2 获取可调用对象的返回值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-多线程的同步问题"><span class="toc-text">3.3 多线程的同步问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Lock-同步锁（原语锁）"><span class="toc-text">3.4 Lock 同步锁（原语锁）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1-同步锁的使用"><span class="toc-text">3.4.1 同步锁的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2-死锁"><span class="toc-text">3.4.2 死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3-重入锁-递归锁"><span class="toc-text">3.4.3 重入锁&#x2F;递归锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-线程实战"><span class="toc-text">4. 线程实战</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-初步的练习和详细解释"><span class="toc-text">4.1 初步的练习和详细解释</span></a></li></ol></li></ol></div></div><div class="post-content"><a id="more"></a>

<h1 id="1-初步认识多线程"><a href="#1-初步认识多线程" class="headerlink" title="1. 初步认识多线程"></a>1. 初步认识多线程</h1><blockquote>
<p>参考<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376" target="_blank" rel="noopener">廖雪峰老师的教程</a></p>
</blockquote>
<p><strong>多进程和多线程</strong><br>我的理解就是<strong>单个CPU</strong>可以执行一个或多个进程，每个任务执行很短时间，从而骗过人的感觉，让我们感觉好像是多个任务一起进行，而<strong>多核CPU</strong>可以并行执行多任务，如果任务数量超过CPU的数量，则会让一个CPU轮流执行多个任务<br>每个进程，也就是每个任务中又分为很多个子任务，也就是线程，一个进程中可以启动多个线程，各个线程中的任务可以同时进行</p>
<p>Python中的多任务执行有三种方式：</p>
<ul>
<li>多进程模式，多个python程序同时进行，每个程序一个线程</li>
<li>多线程模式，一个python程序同时进行多个线程</li>
<li>多进程+多线程，这种模型非常复杂，我的脑子不够用，就不用了</li>
</ul>
<p>我也想要执行一个任务，直来直去，但是总有种情况，我迫不得已要多任务同时进行，我太难了<br>比如我做的GUI，要求可以执行多个任务，但是也要能够暂停其中的一个任务，其他任务不受干扰，好了，废话不多说了，开始学习</p>
<h1 id="2-线程基础"><a href="#2-线程基础" class="headerlink" title="2. 线程基础"></a>2. 线程基础</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 引入线程函数threading</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fund</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'执行的程序'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加一个线程</span></span><br><span class="line">th = Thread(target=fund)</span><br><span class="line"><span class="comment"># 开始进程</span></span><br><span class="line">th.start()</span><br><span class="line"><span class="comment"># 等到一个进程结束时退出</span></span><br><span class="line">th.join()</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p>参考知乎的大佬写的教程<br>作者：Dwzb<br>链接：<a href="https://zhuanlan.zhihu.com/p/34004179" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34004179</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="2-1-线程的开始"><a href="#2-1-线程的开始" class="headerlink" title="2.1 线程的开始"></a>2.1 线程的开始</h2><p><code>th.start()</code> 可以放到循环中，同时进行多个线程</p>
<h2 id="2-2-线程结束时停止"><a href="#2-2-线程结束时停止" class="headerlink" title="2.2 线程结束时停止"></a>2.2 线程结束时停止</h2><p><code>th.join()</code> 加上这句话，则多线程只能一个结束后执行下一个<br>如果没有这句语句，就会直接用多线程开始执行，不会等一个结束再执行下一个</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line">t = time.time()</span><br><span class="line">ths = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = Thread(target = myfun)</span><br><span class="line">    th.start()</span><br><span class="line">    ths.append(th)</span><br><span class="line"><span class="keyword">for</span> th <span class="keyword">in</span> ths:</span><br><span class="line">    th.join()</span><br><span class="line">print(time.time() - t)</span><br><span class="line"><span class="comment"># 结果为 1.0038363933563232</span></span><br></pre></td></tr></tbody></table></figure>

<h2 id="2-3-线程的名称"><a href="#2-3-线程的名称" class="headerlink" title="2.3 线程的名称"></a>2.3 线程的名称</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">print(threading.current_thread().getName())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfun</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(threading.current_thread().name)</span><br><span class="line">    a = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    th = threading.Thread(target = myfun, name = <span class="string">'thread {}'</span>.format(i))</span><br><span class="line">    th.start()</span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">MainThread</span><br><span class="line">thread <span class="number">0</span></span><br><span class="line">thread <span class="number">1</span></span><br><span class="line">thread <span class="number">4</span></span><br><span class="line">thread <span class="number">3</span></span><br><span class="line">thread <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>

<ul>
<li><code>threading.current_thread()</code>表示当前线程，可以调用<code>name</code>或<code>getName()</code>获取线程名称</li>
<li>任何进程的都会有一个主线程，这个进程与新加的线程是相互独立的</li>
<li><code>Thread</code>表示启动一个新的线程<code>name</code>参数表示线程的名字</li>
<li><code>threading.current_thread().getName()</code>是主进程名字<code>MainThread</code>,<code>th.name</code>则是子thread名字</li>
</ul>
<h2 id="2-4-Thread函数"><a href="#2-4-Thread函数" class="headerlink" title="2.4 Thread函数"></a>2.4 Thread函数</h2><p>参数介绍：</p>
<ul>
<li><code>target</code> 线程执行的函数</li>
<li><code>name</code> 线程的名称</li>
<li><code>args</code> target对应得函数得参数，用元组传入，比如<code>func(age,name)</code> <code>Thread(target = func , args = (13, 'name'))</code></li>
<li><code>daemon</code> 主线程默认是false，，如果没有指定则继承父线程的值。True则如果主线程运行结束，该线程也停止运行；False则该线程会继续运行直到运行结束，无视主线程如何</li>
<li><code>group</code> 是预留的一个参数，用于以后扩展ThreadGroup类，现在没用</li>
</ul>
<h2 id="2-5-Thread对象"><a href="#2-5-Thread对象" class="headerlink" title="2.5 Thread对象"></a>2.5 Thread对象</h2><p>属性和方法：</p>
<ul>
<li>name 线程名称</li>
<li>ident 线程标识符号</li>
<li>daemon 是否为守护线程</li>
</ul>
<p><strong>_init</strong>(self, group=None, target=None, name=None, args=(), kwargs=None, *, daemon=None)<br>参数：</p>
<ul>
<li><p>group 无用，保留参数</p>
</li>
<li><p>target 可调用的目标</p>
</li>
<li><p>name 线程的名称</p>
</li>
<li><p>args,kwargs 调用目标的参数</p>
</li>
<li><p>daemon 是否为守护线程</p>
</li>
<li><p>start() 开始执行</p>
</li>
<li><p>join(timeout=None) 阻塞timeout秒，否则直到启动的线程终止前一直挂起</p>
</li>
<li><p>is_alive () 线程是否存活</p>
</li>
<li><p>isDaemon() 是否为守护线程</p>
</li>
<li><p>setDaemon(daemonic) 设置为守护线程</p>
</li>
<li><p>getName()  .name  获取线程名</p>
</li>
<li><p>setName() 设置线程名</p>
</li>
<li><p>start()  join()</p>
</li>
<li><p>join()有一个timeout参数，表示等待这个线程结束时，如果等待时间超过这个时间，就不再等，继续进行下面的代码，但是这个线程不会被中断</p>
</li>
<li><p>run() 也是运行这个线程，但是必须等到这个线程运行结束才会继续执行之后的代码（如果将上面的start全换成run则相当于没有开多线程）</p>
</li>
<li><p>is_alive()如果该线程还没运行完，就是True否则False</p>
</li>
<li><p>daemon 返回该线程的daemon</p>
</li>
<li><p>setDaemon(True)设置线程的daemon</p>
</li>
</ul>
<h2 id="2-6-threading"><a href="#2-6-threading" class="headerlink" title="2.6 threading"></a>2.6 threading</h2><ul>
<li>threading.currentThread(): 返回当前的线程变量</li>
<li>threading.enumerate(): 返回一个包含正在运行的线程的list</li>
<li>threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果</li>
</ul>
<p>threading模块的类对象</p>
<ul>
<li>Thread 执行线程</li>
<li>Timer 在运行前等待一段时间的执行线程</li>
<li>Lock 原语锁（互斥锁，简单锁）</li>
<li>RLock 重入锁，使单一线程可以（再次）获得已持有的锁</li>
<li>Condition 条件变量，线程需要等待另一个线程满足特定条件</li>
<li>Event 事件变量，N个线程等待某个事件发生后激活所有线程</li>
<li>Semaphore 线程间共享资源的寄存器</li>
<li>BoundedSemaphore 与Semaphore 相似，它不允许超过初始值</li>
<li>Barrie 执行线程达到一定数量后才可以继续</li>
</ul>
<p>threading模块的函数</p>
<ul>
<li>activeCount() 获取当前活动中的Thread对象个数</li>
<li>currentThread() 获取当前的Thread对象</li>
<li>enumerate() 获取当前活动的Thread对象列表</li>
<li>settrace(func) 为所有线程设置一个跟踪（trace）函数</li>
<li>setprofile(func) 为所有线程设置配置文件（profile）函</li>
<li>stack_size(size=None) 获取新创建线程的栈大小，也可设置线程栈的大小为size。</li>
</ul>
<h1 id="3-线程进阶"><a href="#3-线程进阶" class="headerlink" title="3. 线程进阶"></a>3. 线程进阶</h1><h2 id="3-1-派生Thread-的子类，并创建子类的实例"><a href="#3-1-派生Thread-的子类，并创建子类的实例" class="headerlink" title="3.1 派生Thread 的子类，并创建子类的实例"></a>3.1 派生Thread 的子类，并创建子类的实例</h2><p>我们可以通过继承Thread类，派生出一个子类，使用子类来创建多线程</p>
<p><strong>记住要在子类中初始化父类的方法Thread.<strong>init</strong>(self) 。需要重构 run() 方法来执行多线程的程序</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Thread 的子类 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param func: 可调用的对象</span></span><br><span class="line"><span class="string">        :param args: 可调用对象的参数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        Thread.__init__(self)   <span class="comment"># 不要忘记调用Thread的初始化方法</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func(*self.args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, sec)</span>:</span></span><br><span class="line">    print(<span class="string">'---开始---'</span>, name, <span class="string">'时间'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'***结束***'</span>, name, <span class="string">'时间'</span>, ctime())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建 Thread 实例</span></span><br><span class="line">    t1 = MyThread(func, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    t2 = MyThread(func, (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 启动线程运行</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-2-获取可调用对象的返回值"><a href="#3-2-获取可调用对象的返回值" class="headerlink" title="3.2 获取可调用对象的返回值"></a>3.2 获取可调用对象的返回值</h2><p>在多线程中运行的程序时与主线程分开，我们没法直接获取线程中程序的返回值。这时就可以使用派生Thread 的子类，将给过保存的实例属性中，通过一个新方法获取运行结果</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep, ctime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Thread 的子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, args)</span>:</span></span><br><span class="line">        <span class="string">'''</span></span><br><span class="line"><span class="string">        :param func: 可调用的对象</span></span><br><span class="line"><span class="string">        :param args: 可调用对象的参数</span></span><br><span class="line"><span class="string">        '''</span></span><br><span class="line">        Thread.__init__(self)</span><br><span class="line">        self.func = func</span><br><span class="line">        self.args = args</span><br><span class="line">        self.result = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.result = self.func(*self.args)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getResult</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name, sec)</span>:</span></span><br><span class="line">    print(<span class="string">'---开始---'</span>, name, <span class="string">'时间'</span>, ctime())</span><br><span class="line">    sleep(sec)</span><br><span class="line">    print(<span class="string">'***结束***'</span>, name, <span class="string">'时间'</span>, ctime())</span><br><span class="line">    <span class="keyword">return</span> sec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 创建 Thread 实例</span></span><br><span class="line">    t1 = MyThread(func, (<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">    t2 = MyThread(func, (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">    <span class="comment"># 启动线程运行</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 等待所有线程执行完毕</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    <span class="comment"># 或线程中程序的运行结果</span></span><br><span class="line">    print(t1.getResult())</span><br><span class="line">    print(t2.getResult())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure>

<h2 id="3-3-多线程的同步问题"><a href="#3-3-多线程的同步问题" class="headerlink" title="3.3 多线程的同步问题"></a>3.3 多线程的同步问题</h2><p>一般在多线程代码中，总会有一些特定的函数或代码块不想被多个线程同时执行，如：修改数据库、更新文件或其他会产生程序冲突的类似情况</p>
<p>当任意数量的线程可以访问临界区的代码，当在同一时刻只能有一个线程可以通过时，就需要使用同步。我们可以选择合适的同步原语，也可以让线程控制机制来执行同步。</p>
<p>最常用的同理原语有：锁/互斥，以及信号量。锁是最简单最低级的机制。信号量用于多线程竞争有限资源的情况。</p>
<blockquote>
<p>强烈推荐<a href="https://zhuanlan.zhihu.com/p/94344847" target="_blank" rel="noopener">大佬的教程</a></p>
</blockquote>
<h2 id="3-4-Lock-同步锁（原语锁）"><a href="#3-4-Lock-同步锁（原语锁）" class="headerlink" title="3.4 Lock 同步锁（原语锁）"></a>3.4 Lock 同步锁（原语锁）</h2><h3 id="3-4-1-同步锁的使用"><a href="#3-4-1-同步锁的使用" class="headerlink" title="3.4.1 同步锁的使用"></a>3.4.1 同步锁的使用</h3><p><strong>加锁 与 解锁</strong></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个锁对象</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获得锁，加锁</span></span><br><span class="line">lock.acquire()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 释放锁，解锁</span></span><br><span class="line">lock.release()</span><br></pre></td></tr></tbody></table></figure>

<p>当我们通过 lock.acquire() 获得锁后线程程将一直执行不会中断，直到该线程 lock.release( )释放锁后线程才有可能被释放(注意：锁被释放后线程不一定会释放)</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个锁对象</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> num  <span class="comment"># 全局变量</span></span><br><span class="line">    <span class="comment"># lock.acquire()  # 获得锁，加锁</span></span><br><span class="line">    num1 = num</span><br><span class="line">    time.sleep(<span class="number">0.1</span>) </span><br><span class="line"><span class="comment"># sleep()操作，当在没有锁的情况下线程将在这里被释放出来，让给下一线程运行，而我们的num值还没有被修改，所以后面线程的num1的取值都是100</span></span><br><span class="line">    num = num1 - <span class="number">1</span></span><br><span class="line">    <span class="comment"># lock.release()  # 释放锁，解锁</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">num = <span class="number">100</span></span><br><span class="line">l = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):  <span class="comment"># 开启100个线程</span></span><br><span class="line">    t = threading.Thread(target=func, args=())</span><br><span class="line">    t.start()</span><br><span class="line">    l.append(t)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待线程运行结束. 等到线程结束后再print num</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l:</span><br><span class="line">    i.join()</span><br><span class="line"></span><br><span class="line">print(num)</span><br></pre></td></tr></tbody></table></figure>

<p>注意：上面代码先将lock.acquire()和lock.release()行注释掉表示不使用锁，取消lock.acquire()和lock.release()行的注释表示使用锁</p>
<p>不使用锁程序运行输出为 99；使用锁程序运行结果为0</p>
<p><strong>Lock 与GIL(全局解释器锁）存在区别</strong></p>
<ul>
<li>Lock 锁的目的，它是为了保护共享的数据，同时刻只能有一个线程来修改共享的数据，而保护不同的数据需要使用不同的锁</li>
<li>GIL用于限制一个进程中同一时刻只有一个线程被CPU调度，GIL的级别比Lock高，GIL是解释器级别</li>
</ul>
<p><strong>GIL与Lock同时存在，程序执行如下：</strong></p>
<blockquote>
<ol>
<li>同时存在两个线程：线程A，线程B</li>
<li>线程A 抢占到GIL，进入CPU执行，并加了Lock，但为执行完毕，线程被释放</li>
<li>线程B 抢占到GIL，进入CPU执行，执行时发现数据被线程A Lock，于是线程B被阻塞</li>
<li>线程B的GIL被夺走，有可能线程A拿到GIL，执行完操作、解锁，并释放GIL</li>
<li>线程B再次拿到GIL，才可以正常执行</li>
</ol>
</blockquote>
<p>通过上述应该能看到，Lock 通过牺牲执行的效率换数据安全</p>
<h3 id="3-4-2-死锁"><a href="#3-4-2-死锁" class="headerlink" title="3.4.2 死锁"></a>3.4.2 死锁</h3><p>多线程最怕的是遇到死锁，两个或两个以上的线程在执行时，因争夺资源被相互锁住而相互等待</p>
<p><em>互锁造成死锁</em></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个锁对象</span></span><br><span class="line">lock1 = threading.Lock()</span><br><span class="line">lock2 = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.fun_A()</span><br><span class="line">        self.fun_B()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_A</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock1.acquire()</span><br><span class="line">        print(<span class="string">'A_1 加锁'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        lock2.acquire()</span><br><span class="line">        print(<span class="string">'A-2 加锁'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        lock2.release()</span><br><span class="line">        print(<span class="string">'A-2 释放'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        lock1.release()</span><br><span class="line">        print(<span class="string">'A-1 释放'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_B</span><span class="params">(self)</span>:</span></span><br><span class="line">        lock2.acquire()</span><br><span class="line">        print(<span class="string">'B-1 加锁'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        lock1.acquire()</span><br><span class="line">        print(<span class="string">'B-2 加锁'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        lock1.release()</span><br><span class="line">        print(<span class="string">'B-1 释放'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        lock2.release()</span><br><span class="line">        print(<span class="string">'B-2 释放'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># 需要四个以上线程，才会出现死锁现象</span></span><br><span class="line">    t1 = MyThread()</span><br><span class="line">    t2 = MyThread()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure>
<p>如果两个锁同时被多个线程运行，就有可能出现死锁，如果没出现死锁，就多运行几遍就会出现死锁现象</p>
<h3 id="3-4-3-重入锁-递归锁"><a href="#3-4-3-重入锁-递归锁" class="headerlink" title="3.4.3 重入锁/递归锁"></a>3.4.3 重入锁/递归锁</h3><p><code>threading.RLock()</code><br>为了支持同一个线程中多次请求同一资源，Python 提供了可重入锁(RLock)。这个RLock内部维护着一个锁(Lock)和一个计数器(counter)变量，counter 记录了acquire 的次数，从而使得资源可以被多次acquire。直到一个线程所有 acquire都被release(计数器counter变为0)，其他的线程才能获得资源。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成一个递归对象</span></span><br><span class="line">Rlock = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.fun_A()</span><br><span class="line">        self.fun_B()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_A</span><span class="params">(self)</span>:</span></span><br><span class="line">        Rlock.acquire()</span><br><span class="line">        print(<span class="string">'A加锁1'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        Rlock.acquire()</span><br><span class="line">        print(<span class="string">'A加锁2'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        Rlock.release()</span><br><span class="line">        print(<span class="string">'A释放1'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        Rlock.release()</span><br><span class="line">        print(<span class="string">'A释放2'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fun_B</span><span class="params">(self)</span>:</span></span><br><span class="line">        Rlock.acquire()</span><br><span class="line">        print(<span class="string">'B加锁1'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        Rlock.acquire()</span><br><span class="line">        print(<span class="string">'B加锁2'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        Rlock.release()</span><br><span class="line">        print(<span class="string">'B释放1'</span>, end=<span class="string">'\t'</span>)</span><br><span class="line">        Rlock.release()</span><br><span class="line">        print(<span class="string">'B释放2'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThread()</span><br><span class="line">    t2 = MyThread()</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></tbody></table></figure>

<p>当运行到程序B时，即使B休眠了3秒也不会切换线程。</p>
<p>使用重入锁时，counter 没有变为0(所有的acquire没有被释放掉)，即使遇到长时间的io操作也不会切换线程。</p>
<h1 id="4-线程实战"><a href="#4-线程实战" class="headerlink" title="4. 线程实战"></a>4. 线程实战</h1><h2 id="4-1-初步的练习和详细解释"><a href="#4-1-初步的练习和详细解释" class="headerlink" title="4.1 初步的练习和详细解释"></a>4.1 初步的练习和详细解释</h2><script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script></div><div class="tags"><a href="/tags/Python/"><i class="fa fa-tag"></i>Python</a></div><div class="post-nav"><a class="pre" href="/2020/04/08/note-cs/">C#-Note</a><a class="next" href="/2020/04/03/yq-fund/">理财笔记</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="search-form"><input id="local-search-input" placeholder="Search" type="text" name="q" results="0"/><div id="local-search-result"></div></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Tags</i></div><div class="tagcloud"><a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15px;">前端</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Bilibili/" style="font-size: 15px;">Bilibili</a> <a href="/tags/Spider/" style="font-size: 15px;">Spider</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Note/" style="font-size: 15px;">Note</a> <a href="/tags/Compete/" style="font-size: 15px;">Compete</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/Jsoup/" style="font-size: 15px;">Jsoup</a> <a href="/tags/VB/" style="font-size: 15px;">VB</a> <a href="/tags/Server/" style="font-size: 15px;">Server</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Lua/" style="font-size: 15px;">Lua</a> <a href="/tags/C/" style="font-size: 15px;">C#</a> <a href="/tags/Questions/" style="font-size: 15px;">Questions</a> <a href="/tags/Api/" style="font-size: 15px;">Api</a> <a href="/tags/Source/" style="font-size: 15px;">Source</a> <a href="/tags/Github/" style="font-size: 15px;">Github</a> <a href="/tags/Life/" style="font-size: 15px;">Life</a> <a href="/tags/Imagination/" style="font-size: 15px;">Imagination</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categories</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%AD%A6%E4%B9%A0%E5%8A%9B/">学习力</a><span class="category-list-count">32</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%83%B3%E8%B1%A1%E5%8A%9B/">想象力</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF%E5%8A%9B/">技术力</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%97%A0%E5%8A%9B/">无力</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%B5%84%E6%BA%90%E5%8A%9B/">资源力</a><span class="category-list-count">3</span></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recent</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/07/review-vb/">VB的作业和复习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/26/css-project-study/">CSS学习中跟着老师做的几个项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/09/learn-ks/">快捷键——让学习更高效</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/08/note-cs/">C#-Note</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/04/python-threading/">Python多线程学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/yq-fund/">理财笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/02/python-pyqt/">Python中PyQt库的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/python-schedule/">Python中schedule库的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/python-pil/">Python中PIL库的学习</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/25/note-hcj/">前端开发的基础知识</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">Yun.Qi.</a> | Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a> | Theme by<a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Maupassant</a><br/><span class="footer-birthday-text">Birthday</span><span class="footer-birthday-date">2020/02/04</span></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><link rel="stylesheet" type="text/css" href="/css/search.css?v=0.0.0"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/javascript" src="/js/copycode.js" successtext="Copy Successed!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>